# -*- coding: utf-8 -*-
"""Computasi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Je0G_BR73UfyrZa_-GZuDWSmxhrLMv_K
"""

!pip install -U -q PyDrive

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

downloaded = drive.CreateFile({'id':'1p0wFmqO81OKc5zkvZqXhjxxhnq1_3Bvm'})
downloaded.GetContentFile('data.csv')

import pandas as pd
data = pd.read_csv('data.csv')
data

sandbox = data[data.delivery_latitude != 0]
sandbox = sandbox[sandbox.delivery_longitude != 0]

sandbox.drop_duplicates(subset=['delivery_latitude']).size

import numpy as np
import matplotlib.pyplot as plt

latitude = sandbox['delivery_latitude'].values
longitude = sandbox['delivery_longitude'].values
x = np.array(list(zip(longitude,latitude)))
print(x.size)

#a = axzoom.add_subplot(111,xlim=(-6.4,-6.05), ylim=(106.6,107), autoscale_on=False)
#a.scatter(latitude, longitude, c='black', s=1)
plt.scatter( longitude[latitude > -6.4], latitude[latitude > -6.4], c='black', s=2)
plt.show()

import math
from sklearn import cluster

def get_distance(cluster,trans):
  transform = np.empty(cluster.size)
  for i in range(cluster.size):
    transform[i] = trans[i][cluster[i]]
  return np.mean(transform)


def get_centroid_distance(centroid):
  c = np.empty(dtype='float',shape=[centroid.shape[0],centroid.shape[0]])
  for i in range(centroid.shape[0]):
    for j in range(centroid.shape[0]):
      c[i][j] = math.sqrt((centroid[i,0]-centroid[j,0])**2 + (centroid[i,1] - centroid[j,1])**2)
     
  return np.mean(c)


def itung_error(c):
    kmeans = cluster.KMeans(n_clusters = c).fit(x)
    label = kmeans.labels_
    center = kmeans.cluster_centers_
    trans = kmeans.transform(x)
    error1 = get_distance(label,trans)
    error2 = get_centroid_distance(center)
    return np.array([error1, error2])

def special_sort(data):
  a = np.sort(data, order='error2')[::-1]
  print(a)
  part1 = a[:5]
  part2 = a[5:]
  part1 = np.sort(part1, order='error1')
  print(part1)
  part2 = np.sort(part2, order='error1')
  print(part2)
  b = np.append(part1,part2)
  return b

import random

BEE_TOTAL = 10
EPOCH = 10
BUILDING_MAX = 1500

bee = np.empty(BEE_TOTAL,dtype='int32')
identity = np.empty([BEE_TOTAL,2])

for i in range(BEE_TOTAL):
    bee[i] = random.randint(100,BUILDING_MAX)

print(bee)
    
for i in range(BEE_TOTAL):
    identity[i] = itung_error(bee[i])
    print(i)
    
#print(error)

dtype = [('bee', float), ('error1', float), ('error2', float)]
bee_error = np.array(list(zip(bee, identity[:,0], identity[:,1])),dtype=dtype)
print(bee_error)


sort = special_sort(bee_error)
print(sort)

def good_bee(bee):
  for i in range(bee.size):
    random_bee = random.randint(bee[i][0]-5, bee[i][0]+5)
    print(random_bee)
    error = itung_error(random_bee)
    print(error)

    if(bee[i][1] > error[0] and bee[i][2] < error[1]):
      print('kena udif')
      bee[i][0] = random_bee
      bee[i][1] = error[0]
      bee[i][2] = error[1]
  
  return bee
 

def bad_bee(bee):
  for i in range(bee.size):
    a = random.randint(100,BUILDING_MAX)
    b = itung_error(a)
    print(a,b)
    
    bee[i][0] = a
    bee[i][1] = b[0]
    bee[i][2] = b[1]
    
  return bee

print(sort)
for i in range(EPOCH):
  a = good_bee(np.append(sort[:3],sort[8:]))
  print(a)
  b = bad_bee(sort[3:8])
  print(b)
  bee = np.append(a,b)
  print(bee)
  sort = special_sort(bee)
  print(sort)
  print(i)

print("Lima terbaik :")
print(bee[:5])
print("Lima pencarian random :")
print(bee[5:])

import scipy.cluster.hierarchy as ch

asd = ch.dendrogram(ch.linkage(x, method = 'ward'))
plt.show()

#plt.scatter( longitude[latitude > -6.4], latitude[latitude > -6.4], c='black', s=2)
#plt.show()

table = pd.DataFrame(x)
t = table.to_csv('bang david.csv',sep=',')
file1 = drive.CreateFile()
file1.SetContentFile('bang david.csv')
file1.Upload()
print('title: %s, id: %s' % (file1['title'], file1['id']))

import os
print(os.system('whereis'))

from sklearn import cluster
import math

kmeans = cluster.KMeans(n_clusters = 4).fit(x)
label = kmeans.labels_
print(label)
center = kmeans.cluster_centers_
print(center)
trans = kmeans.transform(x)
print(trans)
#y = np.array(list(zip(label,transform)))
#print(y)
#print(longitude[1])
#print(latitude[1])
#print(center[label[1],0])
#print(center[label[1],1])
#print(math.sqrt((longitude[1]-center[label[1],0])**2 + (latitude[1] - center[label[1],1])**2 ))
#print(center[label[0],0 - longitude[0])

def get_distance(cluster,trans):
  transform = np.empty(cluster.size)
  for i in range(cluster.size):
    transform[i] = trans[i][cluster[i]]
  return transform

def get_centroid_distance(centroid):
  print(centroid.shape)
  c = np.empty(dtype='float',shape=[centroid.shape[0],centroid.shape[0]])
  for i in range(centroid.shape[0]):
    for j in range(centroid.shape[0]):
      c[i][j] = math.sqrt((centroid[i,0]-centroid[j,0])**2 + (centroid[i,1] - centroid[j,1])**2)
     
  return c

#def get_mean(i)
    
transform = get_distance(label,trans)
#print(transform)
y = np.array(list(zip(label,transform)))
z = get_centroid_distance(center)
a = np.array([])
print(z)
print(np.mean(y[y[:,0] == 0]))
#a = pd.DataFrame(y)
#print(a)

print(sort[:5])
for i in range(sort.size-5):
    random_bee = random.randint(sort[i][0]-5, sort[i][0]+5)
    print(random_bee)
    while(random_bee == sort[i][0]):
      random_bee = random.randint(sort[i][0]-5, sort[i][0]+5)
      print('kena while')
      print(random_bee)
    error = itung_error(random_bee)
    print(error)

    if(sort[i][1] > error):
      print('kena udif')
      sort[i][0] = random_bee
      sort[i][1] = error
      
print(sort)

print(sort[5:])
for i in range(5, sort.size):
    a = random.randint(0,30)
    b = itung_error(a)
    print(a,b)
    
    sort[i][0] = a
    sort[i][1] = b
print(sort)